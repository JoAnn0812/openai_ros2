import abc
# from collections import Iterable, Collection, Sequence
from typing import Sequence, Iterable, Tuple

import gym
import rclpy
# https://bitbucket.org/theconstructcore/theconstruct_msgs/src/master/msg/RLExperimentInfo.msg
# from openai_ros.msg import RLExperimentInfo
from openai_ros2.utils import ut_param_server
from gym.utils import seeding
from std_srvs.srv import Empty

from openai_ros2.utils.gazebo_connection import GazeboConnection
from openai_ros2.robot_base import RobotBase


# https://github.com/openai/gym/blob/master/gym/core.py
class RobotGazeboEnv(gym.Env):
    def __init__(self):
        rclpy.init()
        self.node = rclpy.create_node(self.__class__.__name__)

        # Get robot name from parameter server
        robot_names = ut_param_server.get_robots(self.node)
        self.robot_name = robot_names[0]

        # Create reset client to call the reset service
        self._robot_resetter = self.node.create_client(Empty, '/' + self.robot_name + '/reset')
        self.gazebo = GazeboConnection(self.node)
        self.np_random = None
        self.seed()

        # Set up ROS related variables
        self.episode_num = 0
        self.cumulated_episode_reward = 0
        # self.reward_pub = rospy.Publisher('/openai/reward', RLExperimentInfo, queue_size=1)

        # Launch relevant subprocesses (using ros2 launch)
        # Note: Including these subprocesses will make it undebuggable

    # Env methods
    def seed(self, seed=None) -> list:
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def step(self, action: Sequence[float]) -> Tuple[Sequence[float], float, bool, str]:
        """
        Function executed each time step.
        Here we get the action execute it in a time step and retrieve the
        observations generated by that action.
        :param action:
        :return: obs, reward, done, info
        """

        """
        Here we should convert the action num to movement action, execute the action in the
        simulation and get the observations result of performing that action.
        """

        # TODO add action need to use 1-? 2-?
        self._set_action(action)
        obs = self._get_observations()
        done = self._is_done(obs)
        info = self._get_info()
        reward = self._compute_reward(obs, done)
        self.cumulated_episode_reward += reward

        return obs, reward, done, info

    def reset(self) -> None:
        self._reset_sim()
        self._update_episode()

    @abc.abstractmethod
    def close(self) -> None:
        """
        Function executed when closing the environment.
        Use it for closing GUIS and other systems that need closing.
        :return:
        """
        pass

    @abc.abstractmethod
    def render(self, mode='human') -> None:
        pass

    # Extension methods
    # ----------------------------
    def _update_episode(self) -> None:
        """
        Publishes the cumulated reward of the episode and 
        increases the episode number by one.
        :return:
        """

        # self._publish_reward_topic(
        #     self.cumulated_episode_reward,
        #     self.episode_num
        # )
        self.episode_num += 1
        self.cumulated_episode_reward = 0

    '''def _publish_reward_topic(self, reward, episode_number=1):  #TODO use for publish purposes
        """
        This function publishes the given reward in the reward topic for
        easy access from ROS infrastructure.
        :param reward:
        :param episode_number:
        :return:
        """
        reward_msg = RLExperimentInfo()
        reward_msg.episode_number = episode_number
        reward_msg.episode_reward = reward
        self.reward_pub.publish(reward_msg)'''
    @abc.abstractmethod
    def _reset_controller(self) -> None:
        pass

    @abc.abstractmethod
    def _get_observations(self) -> Sequence[float]:
        pass

    @abc.abstractmethod
    def _get_info(self) -> str:
        pass

    def _reset_sim(self) -> None:
        self.gazebo.pause_sim()
        self.gazebo.reset_sim()
        self._reset_controller()
        self.gazebo.unpause_sim()

    @abc.abstractmethod
    def _set_action(self, action: Sequence[float]) -> None:
        pass

    @abc.abstractmethod
    def _is_done(self, observations: Sequence[float]) -> bool:
        pass

    @abc.abstractmethod
    def _compute_reward(self, observations: Sequence[float], done: bool):
        pass